<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VoterTrace</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
html{scroll-behavior:smooth}
body{font-family:'Inter',system-ui,sans-serif;background:#f8fafc;color:#0f172a;min-height:100vh;font-size:14px;line-height:1.5}

.topbar{position:sticky;top:0;z-index:50;background:#fff;border-bottom:1px solid #e2e8f0;display:flex;align-items:center;padding:0 20px;height:52px;gap:8px}
.topbar-logo{font-weight:700;font-size:15px;color:#0f172a;margin-right:12px}
.tab-btn{padding:6px 14px;border-radius:6px;border:none;background:none;font-size:13px;font-weight:500;color:#64748b;cursor:pointer;transition:all .15s}
.tab-btn:hover{background:#f1f5f9;color:#0f172a}
.tab-btn.on{background:#eff6ff;color:#2563eb;font-weight:600}

.page{display:none;max-width:660px;margin:0 auto;padding:28px 20px 80px}
.page.on{display:block}
.page-title{font-size:20px;font-weight:700;margin-bottom:4px}
.page-sub{font-size:13px;color:#64748b;margin-bottom:24px}

.box{background:#fff;border:1px solid #e2e8f0;border-radius:12px;padding:20px;margin-bottom:14px}
.box-head{font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:.6px;color:#94a3b8;margin-bottom:14px}

/* Upload */
.upload-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
@media(max-width:480px){.upload-grid{grid-template-columns:1fr}}
.slot-label{font-size:11px;font-weight:600;letter-spacing:.4px;margin-bottom:6px;display:block}
.slot-label.f{color:#2563eb}.slot-label.b{color:#7c3aed}

.upload-btn{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;width:100%;padding:20px 12px;border:2px dashed #cbd5e1;border-radius:8px;background:#f8fafc;cursor:pointer;font-family:'Inter',sans-serif;font-size:12px;font-weight:500;color:#64748b;transition:all .15s;text-align:center}
.upload-btn:hover{border-color:#2563eb;background:#eff6ff;color:#2563eb}
.upload-btn.selected{border-color:#16a34a;border-style:solid;background:#f0fdf4;color:#15803d}
.upload-btn .ico{font-size:22px}

.upload-single{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:8px;width:100%;padding:28px 16px;border:2px dashed #cbd5e1;border-radius:8px;background:#f8fafc;cursor:pointer;font-family:'Inter',sans-serif;font-size:13px;font-weight:500;color:#64748b;transition:all .15s;text-align:center}
.upload-single:hover{border-color:#2563eb;background:#eff6ff;color:#2563eb}
.upload-single.selected{border-color:#16a34a;border-style:solid;background:#f0fdf4;color:#15803d}
.upload-single .ico{font-size:28px}

.thumb{width:100%;max-height:110px;object-fit:cover;border-radius:6px;border:1px solid #e2e8f0;margin-top:8px;display:none}

.btn{display:flex;align-items:center;justify-content:center;gap:7px;width:100%;padding:10px 18px;border-radius:8px;border:none;font-family:'Inter',sans-serif;font-size:13px;font-weight:600;cursor:pointer;transition:all .15s;margin-top:12px}
.btn-blue{background:#2563eb;color:#fff}.btn-blue:hover{background:#1d4ed8}.btn-blue:disabled{background:#bfdbfe;cursor:not-allowed}

.prog-wrap{margin-top:10px;display:none}.prog-wrap.on{display:block}
.prog-track{height:4px;background:#e2e8f0;border-radius:2px;overflow:hidden;margin-bottom:5px}
.prog-bar{height:100%;background:#2563eb;border-radius:2px;width:0;transition:width .3s}
.prog-txt{font-size:12px;color:#64748b}

.spin{width:14px;height:14px;border:2px solid rgba(255,255,255,.35);border-top-color:#fff;border-radius:50%;animation:rot .55s linear infinite;flex-shrink:0}
@keyframes rot{to{transform:rotate(360deg)}}

/* Fields */
.field-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
@media(max-width:420px){.field-grid{grid-template-columns:1fr}}
.field-item{background:#f8fafc;border-radius:6px;padding:10px 12px}
.field-item.w2{grid-column:1/-1}
.field-k{font-size:10px;font-weight:600;color:#94a3b8;text-transform:uppercase;letter-spacing:.5px;margin-bottom:3px}
.field-v{font-size:14px;font-weight:500;color:#0f172a;line-height:1.4}
.field-v.nil{font-size:12px;color:#cbd5e1;font-style:italic;font-weight:400}
.field-item{position:relative;}
.copy-btn{
  position:absolute;top:8px;right:8px;
  background:none;border:1px solid #e2e8f0;border-radius:4px;
  padding:2px 7px;font-size:10px;font-weight:600;color:#94a3b8;
  cursor:pointer;transition:all .15s;font-family:'Inter',sans-serif;
  opacity:0;
}
.field-item:hover .copy-btn{opacity:1;}
.copy-btn:hover{background:#eff6ff;border-color:#bfdbfe;color:#2563eb;}
.copy-btn.copied{color:#16a34a;border-color:#bbf7d0;background:#f0fdf4;}

/* Search */
.input-row{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px}
@media(max-width:460px){.input-row{grid-template-columns:1fr}}
.input-group label{display:block;font-size:12px;font-weight:600;color:#475569;margin-bottom:4px}
.input-group input{width:100%;padding:9px 12px;border:1px solid #e2e8f0;border-radius:7px;font-family:'Inter',sans-serif;font-size:13px;color:#0f172a;background:#fff;outline:none;transition:border-color .15s}
.input-group input:focus{border-color:#2563eb;box-shadow:0 0 0 3px #dbeafe}
.input-group input:disabled{background:#f8fafc;color:#cbd5e1;cursor:not-allowed}

/* Results */
.result-item{background:#fff;border:1px solid #e2e8f0;border-radius:10px;padding:16px;margin-bottom:10px;position:relative;transition:border-color .15s}
.result-item:hover{border-color:#bfdbfe}
.result-item.top{border-color:#2563eb}
.result-top-row{display:flex;align-items:flex-start;justify-content:space-between;margin-bottom:10px;gap:10px}
.result-name{font-size:16px;font-weight:700;color:#0f172a}
.result-sub{font-size:12px;color:#64748b;margin-top:2px;line-height:1.5}
.badge{display:inline-block;padding:3px 9px;border-radius:20px;font-size:11px;font-weight:600;flex-shrink:0}
.badge.hi{background:#dcfce7;color:#15803d}.badge.mid{background:#fef9c3;color:#a16207}.badge.lo{background:#fee2e2;color:#b91c1c}
.result-tags{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
.tag{font-size:11px;padding:3px 9px;border-radius:5px;background:#f1f5f9;border:1px solid #e2e8f0;color:#475569}
.tag b{color:#0f172a}.tag.hl{background:#eff6ff;border-color:#bfdbfe;color:#2563eb}.tag.hl b{color:#1d4ed8}
.best-pin{position:absolute;top:-1px;right:12px;background:#2563eb;color:#fff;font-size:10px;font-weight:700;padding:2px 8px;border-radius:0 0 6px 6px;letter-spacing:.3px}

.banner-ok{padding:10px 14px;border-radius:7px;font-size:13px;background:#f0fdf4;border:1px solid #bbf7d0;color:#15803d;font-weight:500}
.notice{display:flex;align-items:center;gap:8px;padding:10px 12px;background:#f8fafc;border:1px solid #e2e8f0;border-radius:7px;font-size:13px;color:#94a3b8;margin-bottom:14px}

.empty{text-align:center;padding:36px 16px;color:#94a3b8}
.empty .e-ico{font-size:30px;margin-bottom:8px}

details{margin-top:12px}
details summary{font-size:12px;color:#94a3b8;cursor:pointer;user-select:none}
details pre{margin-top:8px;background:#f8fafc;border:1px solid #e2e8f0;border-radius:6px;padding:10px;font-size:10px;color:#64748b;white-space:pre-wrap;word-break:break-word;max-height:160px;overflow-y:auto;font-family:monospace}

::-webkit-scrollbar{width:5px}
::-webkit-scrollbar-thumb{background:#e2e8f0;border-radius:3px}
</style>
</head>
<body>

<div class="topbar">
  <span class="topbar-logo">VoterTrace</span>
  <button class="tab-btn on" id="t1" onclick="go('voter-id','t1')">Voter ID Reader</button>
  <button class="tab-btn"    id="t2" onclick="go('roll-search','t2')">Electoral Roll Search</button>
</div>

<!-- PAGE 1: VOTER ID -->
<div class="page on" id="voter-id">
  <p class="page-title">Voter ID Reader</p>
  <p class="page-sub">Upload your voter ID card to extract all details.</p>

  <div class="box">
    <div class="box-head">Upload Card Images</div>
    <div class="upload-grid">
      <div>
        <span class="slot-label f">â–² Front side</span>
        <button class="upload-btn" id="front-btn" onclick="document.getElementById('fi-front').click()">
          <span class="ico">ğŸªª</span>
          <span id="front-lbl">Click to choose image</span>
        </button>
        <input type="file" id="fi-front" accept="image/*" style="display:none">
        <img id="front-thumb" class="thumb" alt="">
      </div>
      <div>
        <span class="slot-label b">â–¼ Back side</span>
        <button class="upload-btn" id="back-btn" onclick="document.getElementById('fi-back').click()">
          <span class="ico">ğŸ </span>
          <span id="back-lbl">Click to choose image</span>
        </button>
        <input type="file" id="fi-back" accept="image/*" style="display:none">
        <img id="back-thumb" class="thumb" alt="">
      </div>
    </div>
    <div class="prog-wrap" id="id-prog">
      <div class="prog-track"><div class="prog-bar" id="id-bar"></div></div>
      <div class="prog-txt" id="id-txt">Scanningâ€¦</div>
    </div>
    <button class="btn btn-blue" id="id-btn" disabled onclick="scanId()">Scan Voter ID</button>
  </div>

  <div id="id-out" style="display:none">
    <div class="box">
      <div class="box-head">Extracted Details</div>
      <div class="field-grid" id="id-fields"></div>
      <details>
        <summary>View raw scanned text</summary>
        <pre id="id-raw"></pre>
      </details>
    </div>
  </div>
</div>

<!-- PAGE 2: ELECTORAL ROLL SEARCH -->
<div class="page" id="roll-search">
  <p class="page-title">Electoral Roll Search</p>
  <p class="page-sub">Upload the electoral roll PDF, then search by name to find voter details.</p>

  <div class="box">
    <div class="box-head">Step 1 â€” Upload Electoral Roll PDF</div>
    <button class="upload-single" id="pdf-btn" onclick="document.getElementById('fi-pdf').click()">
      <span class="ico">ğŸ“„</span>
      <span id="pdf-lbl">Click to choose PDF file</span>
    </button>
    <input type="file" id="fi-pdf" accept="application/pdf" style="display:none">
    <div class="prog-wrap" id="pdf-prog">
      <div class="prog-track"><div class="prog-bar" id="pdf-bar"></div></div>
      <div class="prog-txt" id="pdf-txt">Processingâ€¦</div>
    </div>
    <button class="btn btn-blue" id="pdf-btn-go" disabled onclick="scanPdf()">Process PDF</button>
  </div>

  <div class="box" id="search-box">
    <div class="box-head">Step 2 â€” Search for a Voter</div>
    <div class="notice" id="pdf-not-ready">
      <span style="font-size:16px">â¬†ï¸</span>
      <span>Upload and process the PDF above first, then search here.</span>
    </div>
    <div class="banner-ok" id="pdf-ready-banner" style="display:none;margin-bottom:14px"></div>
    <div class="input-row">
      <div class="input-group">
        <label for="s-name">Voter Name â€” à²®à²¤à²¦à²¾à²°à²° à²¹à³†à²¸à²°à³</label>
        <input id="s-name" type="text" placeholder="à²•à²¨à³à²¨à²¡à²¦à²²à³à²²à²¿ à²¹à³†à²¸à²°à³ à²¬à²°à³†à²¯à²¿à²°à²¿ (à²‰à²¦à²¾: à²¸à³à²¬à³à²°à²®à²£à²¿)" disabled>
      </div>
      <div class="input-group">
        <label for="s-rel">Father / Husband â€” à²¤à²‚à²¦à³† / à²—à²‚à²¡ à²¹à³†à²¸à²°à³</label>
        <input id="s-rel" type="text" placeholder="à²¸à²‚à²¬à²‚à²§à²¿à²¯ à²¹à³†à²¸à²°à³ (à²à²šà³à²›à²¿à²•)" disabled>
      </div>
    </div>
    <button class="btn btn-blue" style="margin-top:0" id="search-btn" disabled onclick="doSearch()">Search</button>
  </div>

  <div id="roll-out" style="display:none">
    <div id="roll-cards"></div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/7.0.0/fuse.min.js"></script>
<script>
pdfjsLib.GlobalWorkerOptions.workerSrc =
  'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

const G = { frontFile:null, backFile:null, pdfFile:null, entries:[] };

// â”€â”€ NAV â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function go(pageId, tabId) {
  document.querySelectorAll('.page').forEach(p=>p.classList.remove('on'));
  document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('on'));
  document.getElementById(pageId).classList.add('on');
  document.getElementById(tabId).classList.add('on');
}

// â”€â”€ FILE INPUT WIRING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Reliable pattern: button.onclick â†’ input.click(), input.onchange reads file
function wireFile(inputId, btnId, lblId, thumbId, onFile) {
  const inp = document.getElementById(inputId);
  const btn = document.getElementById(btnId);
  const lbl = document.getElementById(lblId);
  const thumb = thumbId ? document.getElementById(thumbId) : null;

  inp.addEventListener('change', function() {
    const file = this.files && this.files[0];
    if (!file) return;
    btn.classList.add('selected');
    lbl.textContent = file.name.length > 30 ? file.name.slice(0,28)+'â€¦' : file.name;
    if (thumb && file.type.startsWith('image/')) {
      const fr = new FileReader();
      fr.onload = e => { thumb.src = e.target.result; thumb.style.display = 'block'; };
      fr.readAsDataURL(file);
    }
    onFile(file);
  });

  // Drag-drop support
  btn.addEventListener('dragover', e => { e.preventDefault(); btn.style.borderColor='#2563eb'; });
  btn.addEventListener('dragleave', () => { btn.style.borderColor=''; });
  btn.addEventListener('drop', e => {
    e.preventDefault(); btn.style.borderColor='';
    const file = e.dataTransfer.files && e.dataTransfer.files[0];
    if (!file) return;
    try { const dt=new DataTransfer(); dt.items.add(file); inp.files=dt.files; } catch(x){}
    inp.dispatchEvent(new Event('change'));
  });
}

// â”€â”€ UTILS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _T = null;
function getTess() {
  if (_T) return _T;
  _T = new Promise((res,rej) => {
    if (window.Tesseract) { res(window.Tesseract); return; }
    const s = document.createElement('script');
    s.src = 'https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/5.0.4/tesseract.min.js';
    s.onload = () => res(window.Tesseract);
    s.onerror = rej;
    document.head.appendChild(s);
  });
  return _T;
}

function setPb(barId, txtId, pct, msg) {
  const b=document.getElementById(barId), t=document.getElementById(txtId);
  if (b) b.style.width=Math.min(100,Math.max(0,pct))+'%';
  if (t&&msg!==undefined) t.textContent=msg;
}

function clean(s){ return (s||'').replace(/\s+/g,' ').trim(); }

// â”€â”€ VOTER ID SCAN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function scanId() {
  if (!G.frontFile) { alert('Please choose the front image first.'); return; }
  const btn=document.getElementById('id-btn');
  btn.disabled=true; btn.innerHTML='<span class="spin"></span>Scanningâ€¦';
  document.getElementById('id-prog').classList.add('on');

  try {
    const T = await getTess();

    // Pass 1: front, English + Hindi
    setPb('id-bar','id-txt',5,'Reading front (English)â€¦');
    const w1 = await T.createWorker(['eng','hin'],1,{
      logger:m=>{ if(m.status==='recognizing text') setPb('id-bar','id-txt',5+m.progress*22,'Reading front (English)â€¦'); }
    });
    const frontEng = (await w1.recognize(G.frontFile)).data.text;
    await w1.terminate();

    // Pass 2: front, Kannada
    setPb('id-bar','id-txt',29,'Reading front (Kannada)â€¦');
    const w2 = await T.createWorker(['kan','eng'],1,{
      logger:m=>{ if(m.status==='recognizing text') setPb('id-bar','id-txt',29+m.progress*22,'Reading front (Kannada)â€¦'); }
    });
    const frontKan = (await w2.recognize(G.frontFile)).data.text;
    await w2.terminate();

    let backEng='', backKan='';
    if (G.backFile) {
      setPb('id-bar','id-txt',53,'Reading back (English)â€¦');
      const w3 = await T.createWorker(['eng','hin'],1,{
        logger:m=>{ if(m.status==='recognizing text') setPb('id-bar','id-txt',53+m.progress*18,'Reading back (English)â€¦'); }
      });
      backEng = (await w3.recognize(G.backFile)).data.text;
      await w3.terminate();

      setPb('id-bar','id-txt',73,'Reading back (Kannada)â€¦');
      const w4 = await T.createWorker(['kan','eng'],1,{
        logger:m=>{ if(m.status==='recognizing text') setPb('id-bar','id-txt',73+m.progress*18,'Reading back (Kannada)â€¦'); }
      });
      backKan = (await w4.recognize(G.backFile)).data.text;
      await w4.terminate();
    }

    setPb('id-bar','id-txt',95,'Extracting detailsâ€¦');
    const f = extractId(frontEng, frontKan, backEng, backKan);
    renderIdFields(f, frontEng+'\n\n---KANNADA---\n\n'+frontKan+(backEng?'\n\n---BACK---\n\n'+backEng+'\n\n'+backKan:''));
    setPb('id-bar','id-txt',100,'Done');

  } catch(e) {
    console.error(e);
    alert('Scan error: '+e.message);
  } finally {
    btn.disabled=false; btn.innerHTML='Scan Voter ID';
  }
}

// â”€â”€ EXTRACT VOTER ID FIELDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Guiding principle: ONLY show a field if we found it via an explicit label.
// Never guess or fall back to random lines â€” wrong data is worse than no data.
function extractId(fe, fk, be, bk) {
  be=be||''; bk=bk||''; fk=fk||'';
  const f = {
    electorName:'', electorNameKan:'',
    fatherName:'',  fatherNameKan:'',
    sex:'', epicNo:'',
    addr:'', taluk:'', dist:'',
    part:'', serial:''
  };

  // â”€â”€ EPIC No. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Voter ID EPIC format: 3 letters + 7 digits e.g. BCW0666909
  const allText = fe+' '+be;
  const epicM = allText.match(/\b([A-Z]{3}[0-9]{7})\b/)
             || allText.match(/IDENTITY\s*CARD\s+([A-Z]{3}[A-Z0-9]{6,8})/i)
             || allText.match(/\b([A-Z]{3}[O][0-9]{6,7})\b/i);
  if (epicM) f.epicNo = epicM[1].toUpperCase().replace(/^([A-Z]{3})O/,'$10');

  // â”€â”€ ENGLISH FIELDS â€” strictly label-anchored â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Each field is only populated if the label is found.
  // The label must appear on the same line as, or immediately before, the value.

  // Elector's Name
  const enameM = matchLabelledField(fe, [
    /elector'?s?\s*name\s*[:\-]\s*/i,
    /voter'?s?\s*name\s*[:\-]\s*/i,
  ]);
  if (enameM) f.electorName = enameM;

  // Father's / Husband's Name
  const fnameM = matchLabelledField(fe, [
    /father'?s?\s*name\s*[:\-]\s*/i,
    /husband'?s?\s*name\s*[:\-]\s*/i,
  ]);
  if (fnameM) f.fatherName = fnameM;

  // Sex
  const sexM = fe.match(/\bsex\s*[:\-]\s*(male|female|m|f)\b/i)
            || fe.match(/à²²à²¿à²‚à²—\s*[:\-]?\s*(à²ªà³|à²¸à³à²¤à³à²°à³€)/);
  if (sexM) {
    const s = sexM[1].toLowerCase();
    f.sex = (s==='m'||s==='male'||s==='à²ªà³') ? 'Male' : 'Female';
  }

  // â”€â”€ KANNADA FIELDS â€” strictly label-anchored only â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // We look for the Kannada label text and take ONLY the value that
  // follows on the same line (after the colon) or the very next line
  // if that next line has no colon (i.e. it's a value continuation).
  // We NEVER go beyond 1 continuation line, and NEVER grab text that
  // contains dates, numbers, or known noise patterns.

  f.electorNameKan = kanLabelField(fk, [
    /à²®à²¤à²¦à²¾à²°à²°\s*à²¹à³†à²¸à²°à³\s*[:\-]?/,
    /à²®à²¤à²¦à²¾à²°\s*à²¹à³†à²¸à²°\s*[:\-]?/,
  ]);

  f.fatherNameKan = kanLabelField(fk, [
    /à²¤à²‚à²¦à³†à²¯\s*à²¹à³†à²¸à²°à³\s*[:\-]?/,
    /à²¤à²‚à²¦à³†\s*à²¹à³†à²¸à²°\s*[:\-]?/,
    /à²ªà²¤à²¿à²¯\s*à²¹à³†à²¸à²°à³\s*[:\-]?/,
    /à²¤à²‚à²¦à³†\s*[:\-]\s*/,
  ]);

  // â”€â”€ ADDRESS (back side only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (be) {
    const addrM = be.match(/address\s*[:\-]\s*([^\n]{5,80})/i);
    if (addrM) f.addr = clean(addrM[1]);
    const talukM = be.match(/taluk\s*[:\-]\s*([A-Za-z ()\-]{3,50})/i);
    if (talukM) f.taluk = clean(talukM[1]);
    const distM = be.match(/district\s*[:\-]\s*([A-Za-z ]{3,40})/i);
    if (distM) f.dist = clean(distM[1]);
    const pts=[];
    if (f.addr) pts.push(f.addr);
    if (f.taluk) pts.push(f.taluk+' Taluk');
    if (f.dist) pts.push(f.dist+' District');
    if (pts.length) f.addr = pts.join(', ');
    // Part/Serial from back "NNN / NNN" pattern
    const slM = be.match(/\b(\d{1,4})\s*\/\s*(\d{1,4})\s*$/m);
    if (slM) { f.serial=slM[1]; f.part=slM[2]; }
  }

  return f;
}

// Match an English labelled field: find label, return text after it on same line.
// Also checks the next line if the same line has nothing after the label.
function matchLabelledField(text, labelPatterns) {
  const lines = text.split('\n').map(l=>l.trim()).filter(Boolean);
  for (const re of labelPatterns) {
    for (let i=0; i<lines.length; i++) {
      if (!re.test(lines[i])) continue;
      // Value = everything after the label on the same line
      const afterLabel = lines[i].replace(re,'').trim();
      // Must be a plausible name: starts with capital, only letters/spaces/dots
      const nameRe = /^[A-Z][A-Za-z .'-]{1,50}$/;
      if (nameRe.test(afterLabel)) return clean(afterLabel);
      // Try next line if same line was empty after label
      if (!afterLabel && i+1 < lines.length) {
        const nx = lines[i+1].trim();
        if (nameRe.test(nx)) return clean(nx);
      }
    }
  }
  return '';
}

// Match a Kannada labelled field â€” strict version:
// 1. Find the label line
// 2. Take value from same line after label, OR from the VERY NEXT line
// 3. Value must be ONLY Kannada script words (no digits, no dates, no English)
// 4. If value looks noisy, return '' rather than bad data
function kanLabelField(kanText, labelPatterns) {
  const lines = kanText.split('\n').map(l=>l.trim()).filter(Boolean);

  // Noise patterns â€” if extracted value contains these, reject it
  const noiseRe = /\d{2,}|NE\s*a|Date|à²¦à²¿à²¨à²¾à²‚à²•|à²¸à²°à³à²•à²¾à²°|à²¯à³‹à²œà²¨|à²šà³à²¨à²¾|à²­à²¾à²°à²¤|à²†à²¯à³‹à²—|à²—à³à²°à³à²¤à²¿à²¨|à²šà³€à²Ÿà²¿|à²šà³€à²Ÿ|à²µà³à²¯à²¾à²ªà³à²¤à²¿|à²ªà²Ÿà³à²Ÿà²¿|à²®à²¾à²¹à²¿à²¤à²¿/;

  for (const re of labelPatterns) {
    for (let i=0; i<lines.length; i++) {
      if (!re.test(lines[i])) continue;

      // Get text after label on the same line
      const sameLine = lines[i].replace(re,'').replace(/^[\s:|â€“\-]+/,'').trim();

      let candidate = '';

      if (sameLine && /[\u0C80-\u0CFF]{2,}/.test(sameLine)) {
        candidate = sameLine;
      } else if (i+1 < lines.length) {
        // Next line â€” only if it's purely Kannada (no colon = not a label)
        const nx = lines[i+1].trim();
        if (/[\u0C80-\u0CFF]{3,}/.test(nx) && !/:/.test(nx) && !/[A-Za-z]{3,}/.test(nx)) {
          candidate = nx;
        }
      }

      if (!candidate) continue;
      if (noiseRe.test(candidate)) continue;  // reject noisy result

      // Clean: strip any leading OCR artifacts (|, :, digits, spaces)
      candidate = candidate.replace(/^[\s\d|.:â€“\-]+/, '').trim();

      // Final check: must have meaningful Kannada content (â‰¥ 3 Kannada chars)
      if ((candidate.match(/[\u0C80-\u0CFF]/g)||[]).length >= 3) {
        return candidate;
      }
    }
  }
  return '';  // Return empty rather than wrong data
}

function renderIdFields(f, raw) {
  // Build rows using the exact label language from the card
  const rows = [
    { k:"Elector's Name",           v: f.electorName,    w:false, copy:true },
    { k:"Elector's Name (Kannada)", v: f.electorNameKan, w:false, copy:true, h:!f.electorNameKan },
    { k:"Father's Name",            v: f.fatherName,     w:false, copy:true },
    { k:"Father's Name (Kannada)",  v: f.fatherNameKan,  w:false, copy:true, h:!f.fatherNameKan },
    { k:"Sex",                      v: f.sex,            w:false, h:!f.sex },
    { k:"EPIC No.",                 v: f.epicNo,         w:false, copy:true },
    { k:"Address",                  v: f.addr,           w:true,  copy:true, h:!f.addr },
    { k:"Part No.",                 v: f.part,           w:false, h:!f.part },
    { k:"Serial No.",               v: f.serial,         w:false, h:!f.serial },
  ].filter(r=>!r.h);

  document.getElementById('id-fields').innerHTML = rows.map(r=>`
    <div class="field-item${r.w?' w2':''}">
      <div class="field-k">${r.k}</div>
      <div class="field-v${r.v?'':' nil'}">${r.v||'Not found'}</div>
      ${r.copy&&r.v?`<button class="copy-btn" onclick="copyField(this,'${r.v.replace(/'/g,"\'")}')" title="Copy">Copy</button>`:''}
    </div>`).join('');
  document.getElementById('id-raw').textContent = raw;
  document.getElementById('id-out').style.display='block';
  document.getElementById('id-out').scrollIntoView({behavior:'smooth',block:'start'});
}

function copyField(btn, text) {
  navigator.clipboard.writeText(text).then(()=>{
    btn.textContent='Copied!';
    btn.classList.add('copied');
    setTimeout(()=>{ btn.textContent='Copy'; btn.classList.remove('copied'); }, 1800);
  }).catch(()=>{
    // Fallback for browsers without clipboard API
    const ta=document.createElement('textarea');
    ta.value=text; ta.style.position='fixed'; ta.style.opacity='0';
    document.body.appendChild(ta); ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    btn.textContent='Copied!'; btn.classList.add('copied');
    setTimeout(()=>{ btn.textContent='Copy'; btn.classList.remove('copied'); }, 1800);
  });
}

// â”€â”€ PDF SCAN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Strategy:
//   1. Try native text extraction first (fast, <5s for any PDF)
//   2. If native text is sparse/empty, fall back to OCR with 4 parallel workers
//   Electoral roll PDFs are usually scanned images â†’ OCR path is common
async function scanPdf() {
  if (!G.pdfFile) { alert('Please choose a PDF file first.'); return; }
  const btn=document.getElementById('pdf-btn-go');
  btn.disabled=true; btn.innerHTML='<span class="spin"></span>Processingâ€¦';
  document.getElementById('pdf-prog').classList.add('on');
  G.entries=[];

  try {
    const buf = await G.pdfFile.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({data:buf}).promise;
    const total = pdf.numPages;
    setPb('pdf-bar','pdf-txt',2,`Checking PDF format (${total} pages)â€¦`);

    // â”€â”€ Step 1: Try native text on first 3 pages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let nativeTextTotal = 0;
    for (let pn=1; pn<=Math.min(3,total); pn++) {
      const pg = await pdf.getPage(pn);
      const tc = await pg.getTextContent();
      nativeTextTotal += tc.items.filter(i=>i.str&&i.str.trim().length>1).length;
    }
    const hasNativeText = nativeTextTotal > 30; // meaningful text per page

    if (hasNativeText) {
      // â”€â”€ Native text path â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      setPb('pdf-bar','pdf-txt',5,'Extracting native textâ€¦');
      const pagePromises = Array.from({length:total},(_,i)=>
        pdf.getPage(i+1).then(pg=>pg.getTextContent().then(tc=>({pn:i+1,tc})))
      );
      let done=0;
      const allData=[];
      for (let i=0;i<pagePromises.length;i+=10) {
        const batch=await Promise.all(pagePromises.slice(i,i+10));
        allData.push(...batch);
        done=allData.length;
        setPb('pdf-bar','pdf-txt',5+Math.round(done/total*80),`Extracted ${done}/${total} pagesâ€¦`);
      }
      setPb('pdf-bar','pdf-txt',88,'Parsing entriesâ€¦');
      for (const {pn,tc} of allData.sort((a,b)=>a.pn-b.pn)) {
        G.entries.push(...parseNativePage(tc,pn));
      }
    } else {
      // â”€â”€ OCR path: 4 parallel Tesseract workers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      setPb('pdf-bar','pdf-txt',3,'Loading OCR engineâ€¦');
      const T = await getTess();
      setPb('pdf-bar','pdf-txt',5,`Starting OCR on ${total} pages with 4 workersâ€¦`);

      // Create 4 workers upfront
      const N_WORKERS = 4;
      const workers = await Promise.all(
        Array.from({length:N_WORKERS}, () => T.createWorker(['kan','eng'], 1))
      );

      // Render all pages to canvas (can do this quickly in parallel)
      const canvases = [];
      setPb('pdf-bar','pdf-txt',8,'Rendering pagesâ€¦');
      for (let pn=1; pn<=total; pn++) {
        const pg = await pdf.getPage(pn);
        // Scale 1.2 = good balance of speed vs accuracy for printed text
        const vp = pg.getViewport({scale:1.2});
        const cv = document.createElement('canvas');
        cv.width=vp.width; cv.height=vp.height;
        await pg.render({canvasContext:cv.getContext('2d'),viewport:vp}).promise;
        // Convert to blob URL for Tesseract (more reliable than canvas element)
        const blob = await new Promise(res => cv.toBlob(res,'image/jpeg',0.85));
        const url = URL.createObjectURL(blob);
        canvases.push({pn, url});
        if (pn % 5 === 0) setPb('pdf-bar','pdf-txt',8+Math.round(pn/total*22),`Rendered ${pn}/${total} pagesâ€¦`);
      }
      setPb('pdf-bar','pdf-txt',32,'Running OCRâ€¦');

      // Distribute pages across 4 workers
      let donePages = 0;
      const chunks = Array.from({length:N_WORKERS},()=>[]);
      canvases.forEach((c,i) => chunks[i % N_WORKERS].push(c));

      async function ocrChunk(worker, pages) {
        const results=[];
        for (const {pn,url} of pages) {
          const {data:{text}} = await worker.recognize(url);
          URL.revokeObjectURL(url);
          results.push({pn, text});
          donePages++;
          const pct = 32+Math.round(donePages/total*62);
          setPb('pdf-bar','pdf-txt',pct,`OCR: ${donePages}/${total} pagesâ€¦`);
        }
        return results;
      }

      const allResults = (await Promise.all(
        workers.map((w,i) => ocrChunk(w, chunks[i]))
      )).flat().sort((a,b)=>a.pn-b.pn);

      await Promise.all(workers.map(w=>w.terminate()));

      setPb('pdf-bar','pdf-txt',96,'Parsing voter entriesâ€¦');
      for (const {pn,text} of allResults) {
        G.entries.push(...parseOcrPage(text, pn));
      }
    }

    // Sort entries
    G.entries.sort((a,b)=>(a.pageNum-b.pageNum)||((+a.serial||0)-(+b.serial||0)));
    setPb('pdf-bar','pdf-txt',100,`Done â€” ${G.entries.length} voter entries found across ${total} pages`);

    // Enable search
    document.getElementById('pdf-not-ready').style.display='none';
    const rb=document.getElementById('pdf-ready-banner');
    rb.textContent=`âœ“ ${G.entries.length} voter entries loaded from ${total} pages. Enter a name to search.`;
    rb.style.display='block';
    document.getElementById('s-name').disabled=false;
    document.getElementById('s-rel').disabled=false;
    document.getElementById('search-btn').disabled=false;
    document.getElementById('search-box').scrollIntoView({behavior:'smooth',block:'start'});

  } catch(e) {
    console.error(e);
    alert('PDF processing error: '+e.message);
  } finally {
    btn.disabled=false; btn.innerHTML='Process PDF';
  }
}

// â”€â”€ PARSE NATIVE TEXT PAGE (for text-layer PDFs) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function parseNativePage(tc, pageNum) {
  const items = tc.items
    .filter(i=>i.str&&i.str.trim())
    .map(i=>({
      text:i.str.trim(),
      x:Math.round(i.transform[4]),
      y:Math.round(i.transform[5])
    }));
  if (!items.length) return [];

  // Group by Y row (tolerance 4px)
  const sorted=[...items].sort((a,b)=>b.y-a.y);
  const rows=[];
  for (const item of sorted) {
    const row=rows.find(r=>Math.abs(r[0].y-item.y)<=4);
    if (row) row.push(item); else rows.push([item]);
  }

  // Part No from header
  let partNo='';
  const topLines=rows.slice(0,5).map(r=>r.sort((a,b)=>a.x-b.x).map(i=>i.text).join(' '));
  for (const ln of topLines) {
    const pm=ln.match(/à²­à²¾à²—à²¦\s*à²¸à²‚à²–à³à²¯à³†\s*[:\-]?\s*(\d+)|à²­à²¾à²—\s*[:\-#]?\s*(\d+)/);
    if (pm){partNo=pm[1]||pm[2];break;}
  }

  return parseTablePage(rows, partNo, pageNum);
}

// â”€â”€ PARSE COLUMNAR TABLE PAGE (Karnataka electoral roll format) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Table columns (from the format image):
//   Col 1 (narrowest, leftmost):  à²•à³à²°à²® à²¸à²‚à²–à³à²¯à³†  â€” Serial No
//   Col 2:                         à²®à²¨à³†/à²«à³à²²à²¾à²Ÿà³    â€” House No
//   Col 3 (widest):                à²®à²¤à²¦à²¾à²°à²° à²¹à³†à²¸à²°à³  â€” Voter Name
//   Col 4 (narrow):                à²¸à²‚à²¬à²‚à²§          â€” Relation (à²¤à²‚à²¦à³†/à²—à²‚à²¡/à²¤à²¾à²¯à²¿/à²‡à²¤à²°à³†)
//   Col 5:                         à²¸à²‚à²¬à²‚à²§à²¿à²¯ à²¹à³†à²¸à²°à³ â€” Relative Name
//   Col 6 (narrow):                à²—à²‚/à²¹à³†à²‚         â€” Sex
//   Col 7 (narrow):                à²µà²¯à²¸à³à²¸à³         â€” Age
//   Col 8 (narrow):                à²®.à²—à³.à²šà³€ à²¸à²‚à²–à³à²¯à³† â€” EPIC No (often blank in scanned PDFs)
//
// When OCR runs on this, each data row becomes ONE line like:
//   "1  2  à²¸à³à²¬à³à²°à²®à²£à²¿  à²¤à²‚à²¦à³†  à²…à²¯à³à²¯à²•à³à²£  à²—à²‚  35"
// We parse this by detecting the known fixed values in cols 4 and 6.
function parseTablePage(rows, partNo, pageNum) {
  const entries=[];

  // Reconstruct lines from rows
  const lines = rows
    .map(r=>r.sort((a,b)=>a.x-b.x).map(i=>i.text).join('\t'))
    .filter(Boolean);

  // Relation tokens â€” col 4 values
  const REL_TOKENS = /^(à²¤à²‚à²¦à³†|à²—à²‚à²¡|à²¤à²¾à²¯à²¿|à²‡à²¤à²°à³†|à²ªà²¤à²¿|à²®à²—|à²®à²—à²³à³)$/;
  // Sex tokens â€” col 6 values
  const SEX_TOKENS = /^(à²—à²‚|à²¹à³†à²‚|à²—à²‚\.|à²¹à³†à²‚\.)$/;

  for (const rawLine of lines) {
    // Split by whitespace/tab into tokens
    const tokens = rawLine.split(/[\t]+/).map(t=>t.trim()).filter(Boolean);

    // Skip header/footer lines
    if (tokens.join(' ').match(/à²•à³à²°à²®\s*à²¸à²‚à²–à³à²¯à³†|à²®à²¨à³†.*à²«à³à²²à²¾à²Ÿà³|à²®à²¤à²¦à²¾à²°à²°\s*à²¹à³†à²¸à²°à³|à²­à²¾à²—à²¦|à²®à²¤à²¦à²¾à²°à²°\s*à²ªà²Ÿà³à²Ÿà²¿|à²°à²¾à²œà³à²¯à²¦\s*à²•à³‹à²¡à³/)) continue;
    if (tokens.join(' ').match(/à²µà²¿à²§à²¾à²¨\s*à²¸à²­à²¾|à²­à²¾à²°à²¤\s*à²šà³à²¨à²¾/)) continue;

    // Find relation token position â€” this is the most reliable anchor
    let relIdx = -1;
    for (let t=0;t<tokens.length;t++) {
      if (REL_TOKENS.test(tokens[t])) { relIdx=t; break; }
    }
    if (relIdx < 0) continue; // Not a data row

    // Find sex token (comes after relation)
    let sexIdx = -1;
    for (let t=relIdx+1;t<tokens.length;t++) {
      if (SEX_TOKENS.test(tokens[t])) { sexIdx=t; break; }
    }

    // Serial = first numeric token before relation
    let serial='', houseNo='', nameKan='', relationType='', relativeKan='', sex='', age='', epicNo='';

    // Tokens before relation: [serial] [houseNo] [name...]
    const preRel = tokens.slice(0, relIdx);
    // Serial: first token if purely numeric
    let preStart=0;
    if (preRel.length>0 && /^\d+$/.test(preRel[0])) {
      serial=preRel[0]; preStart=1;
    }
    // House no: next token if purely numeric
    if (preRel.length>preStart && /^\d+$/.test(preRel[preStart])) {
      houseNo=preRel[preStart]; preStart++;
    }
    // Voter name: remaining tokens
    nameKan = preRel.slice(preStart).join(' ').trim();

    // Relation type
    relationType = tokens[relIdx];

    // Relative name: tokens between relation and sex
    const postRel = tokens.slice(relIdx+1, sexIdx>=0 ? sexIdx : tokens.length);
    relativeKan = postRel.join(' ').trim();

    // Sex
    if (sexIdx>=0) {
      sex = SEX_TOKENS.test(tokens[sexIdx]) ?
        (tokens[sexIdx].startsWith('à²—à²‚') ? 'à²—à²‚ (Male)' : 'à²¹à³†à²‚ (Female)') : '';
    }

    // Age + EPIC: tokens after sex
    const postSex = tokens.slice(sexIdx>=0 ? sexIdx+1 : tokens.length);
    for (const t of postSex) {
      if (/^\d{1,3}$/.test(t) && parseInt(t)>0 && parseInt(t)<120 && !age) { age=t; }
      else if (/^[A-Z]{3}\d{7}$/.test(t)) { epicNo=t; }
    }

    // Only add if we have a name
    if (nameKan.length>1) {
      entries.push({
        serial, houseNo, partNo, pageNum,
        nameKan, name:'',           // No English names in Kannada rolls
        relativeKan, relative:'',
        relationType,
        sex, age, epicNo,
        address: houseNo ? 'House No. '+houseNo : ''
      });
    }
  }

  return entries;
}

// â”€â”€ PARSE OCR PAGE (for scanned image PDFs) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Karnataka electoral roll: pure Kannada tabular format.
// Each row: <serial>  <houseNo>  <voterName>  <relation>  <relativeName>  <sex>  <age>
// Relation words: à²¤à²‚à²¦à³† (father) à²—à²‚à²¡ (husband) à²¤à²¾à²¯à²¿ (mother) à²‡à²¤à²°à³† (other) à²ªà²¤à²¿ (husband)
// Sex tokens: à²—à²‚ (male) à²¹à³†à²‚ (female)
//
// OCR artefacts we handle:
//   - "$" prefix on numbers  (e.g. "$65" â†’ "65")
//   - Trailing "." on Kannada words  (e.g. "à²¤à²‚à²¦à³†." â†’ "à²¤à²‚à²¦à³†")
//   - "|" instead of space
//   - Relation word on a separate line from the voter name
function parseOcrPage(text, pageNum, knownPart) {
  const rawLines = text.split('\n').map(l => l.trim()).filter(Boolean);

  // â”€â”€ Part number â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let partNo = knownPart || '';
  if (!partNo) {
    for (const ln of rawLines.slice(0, 30)) {
      const pm = ln.match(/à²­à²¾à²—à²¦\s*à²¸à²‚à²–à³à²¯à³†\s*[:\-]?\s*(\d+)/i)
              || ln.match(/à²­à²¾à²—\s*à²¸à²‚à²–à³à²¯à³†\s*[:\-]?\s*(\d+)/i)
              || ln.match(/à²­à²¾à²—\s*[:\-#]\s*(\d+)/i)
              || ln.match(/part\s*[:\-#]?\s*(\d+)/i);
      if (pm) { partNo = pm[1]; break; }
    }
  }

  // â”€â”€ Pre-clean lines â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Remove OCR artifacts so token matching is reliable
  function cleanLine(ln) {
    return ln
      .replace(/\|/g, ' ')                    // | â†’ space
      .replace(/^\$\s*/, '')                   // leading $
      .replace(/\$(\d)/g, '$1')               // $65 â†’ 65
      .replace(/([\u0C80-\u0CFF])\.(\s|$)/g, '$1$2') // dot after Kannada char
      .replace(/\s+/g, ' ')
      .trim();
  }

  // Canonical form of a token for matching (strip dots, dashes, spaces)
  function canon(t) { return t.replace(/[.\-\s]/g, ''); }

  // Relation token exact match (canonical)
  const REL_CANON = new Set(['à²¤à²‚à²¦à³†','à²—à²‚à²¡','à²¤à²¾à²¯à²¿','à²‡à²¤à²°à³†','à²ªà²¤à²¿','à²¸à³à²µà²‚à²¤','à²…à²®à³à²®']);
  // Sex token exact match (canonical)
  const SEX_CANON = new Set(['à²—à²‚','à²¹à³†à²‚']);

  // Header patterns to skip
  const HEADER_RE = /à²•à³à²°à²®\s*à²¸à²‚à²–à³à²¯à³†|à²®à²¨à³†.*à²«à³à²²à²¾à²Ÿà³|à²®à²¤à²¦à²¾à²°à²°\s*à²¹à³†à²¸à²°à³|à²­à²¾à²—à²¦\s*à²¸à²‚à²–à³à²¯à³†|à²°à²¾à²œà³à²¯à²¦\s*à²•à³‹à²¡à³|à²µà²¿à²§à²¾à²¨\s*à²¸à²­à²¾|à²­à²¾à²°à²¤\s*à²šà³à²¨à²¾|à²¸à²‚à²¬à²‚à²§|à²®\.à²—à³\.à²šà³€|à²µà²¿à²­à²¾à²—\s*[:\-]|à²¸à²‚à²–à³à²¯à³†.*à²®à²¤à³à²¤à³|à²®à²¤à²¦à²¾à²°à²°\s*à²ªà²Ÿà³à²Ÿà²¿/;

  const entries = [];

  // â”€â”€ Method A: Single-line table row parser â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Each cleaned line is tokenised; we find the relation token as anchor.
  // Pre-relation: [serial] [houseNo] [name wordsâ€¦]
  // Post-relation: [relative name wordsâ€¦] [sex] [age] [optional epicNo]
  for (const rawLn of rawLines) {
    if (HEADER_RE.test(rawLn)) continue;

    const ln = cleanLine(rawLn);
    if (!ln || ln.length < 3) continue;

    const tokens = ln.split(/\s+/);

    // Find relation anchor
    let relIdx = -1;
    for (let t = 0; t < tokens.length; t++) {
      if (REL_CANON.has(canon(tokens[t]))) { relIdx = t; break; }
    }
    if (relIdx < 0) continue;

    // Find sex anchor (after relation)
    let sexIdx = -1;
    for (let t = relIdx + 1; t < tokens.length; t++) {
      if (SEX_CANON.has(canon(tokens[t]))) { sexIdx = t; break; }
    }

    // Pre-relation: extract serial, houseNo, voter name
    const preRel = tokens.slice(0, relIdx);
    let serial = '', houseNo = '', preStart = 0;

    // Serial: first numeric token (allow $-prefix artefact)
    if (preRel.length > 0) {
      const c0 = canon(preRel[0]);
      if (/^\d+$/.test(c0)) { serial = c0; preStart = 1; }
    }
    // House no: next numeric token
    if (preRel.length > preStart) {
      const c1 = canon(preRel[preStart]);
      if (/^\d+$/.test(c1)) { houseNo = c1; preStart++; }
    }
    // Voter name: rest of pre-relation tokens, cleaned
    const nameKan = preRel.slice(preStart)
      .map(t => canon(t))          // strip trailing dots
      .filter(t => /[\u0C80-\u0CFF]/.test(t))  // only Kannada content
      .join(' ')
      .trim();

    // Relation type (canonical)
    const relationType = canon(tokens[relIdx]);

    // Relative name: between relation and sex
    const relEnd = sexIdx >= 0 ? sexIdx : tokens.length;
    const relativeKan = tokens.slice(relIdx + 1, relEnd)
      .map(t => canon(t))
      .filter(t => /[\u0C80-\u0CFF]/.test(t))
      .join(' ')
      .trim();

    // Sex
    let sex = '';
    if (sexIdx >= 0) {
      sex = canon(tokens[sexIdx]) === 'à²—à²‚' ? 'à²—à²‚ (Male)' : 'à²¹à³†à²‚ (Female)';
    }

    // Age + EPIC from post-sex tokens
    let age = '', epicNo = '';
    const postSex = sexIdx >= 0 ? tokens.slice(sexIdx + 1) : [];
    for (const t of postSex) {
      const ct = canon(t);
      if (/^\d{1,3}$/.test(ct) && parseInt(ct) > 0 && parseInt(ct) < 120 && !age) {
        age = ct;
      } else if (/^[A-Z]{3}\d{7}$/.test(ct)) {
        epicNo = ct;
      }
    }

    if (nameKan.length > 1) {
      entries.push({
        serial, houseNo, partNo, pageNum,
        nameKan, name: '',
        relativeKan, relative: '',
        relationType, sex, age, epicNo,
        address: houseNo ? 'House No. ' + houseNo : ''
      });
    }
  }

  // â”€â”€ Method B: fallback for mangled OCR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (entries.length === 0) return parseOcrFallback(text, partNo, pageNum);
  return entries;
}

// â”€â”€ FALLBACK parser for OCR text that doesn't match table structure â”€â”€
function parseOcrFallback(text, partNo, pageNum) {
  const entries=[];
  const lines=text.split('\n').map(l=>l.trim()).filter(Boolean);
  let i=0;
  while(i<lines.length){
    const ln=lines[i];
    const ser=ln.match(/^(\d{1,4})[.)]\s*(.*)$/)||ln.match(/^(\d{1,4})\s*$/);
    if(ser&&parseInt(ser[1])>=1&&parseInt(ser[1])<=9999){
      const serial=ser[1];
      const block=ser[2]?[ser[2].trim()]:[];
      let j=i+1;
      while(j<lines.length&&j<i+10){
        const nx=lines[j];
        if(/^(\d{1,4})[.)]/.test(nx)||/^(\d{1,4})\s*$/.test(nx)) break;
        if(/à²šà³à²¨à²¾|à²­à²¾à²°à²¤\s*à²¸à²°à³à²•à²¾à²°/i.test(nx)) break;
        block.push(nx); j++;
      }
      // Quick parse
      let nameKan='',relativeKan='',sex='',age='';
      for(const b of block){
        const am=b.match(/(\d{2,3})/);
        const sm=b.match(/\b(à²—à²‚|à²¹à³†à²‚)\b/);
        const rm=b.match(/\b(à²¤à²‚à²¦à³†|à²—à²‚à²¡|à²¤à²¾à²¯à²¿|à²‡à²¤à²°à³†)\b/);
        if(am&&parseInt(am[1])>0&&parseInt(am[1])<120&&!age)age=am[1];
        if(sm)sex=sm[1].includes('à²—à²‚')?'à²—à²‚ (Male)':'à²¹à³†à²‚ (Female)';
        if(!nameKan&&/[\u0C80-\u0CFF]{3,}/.test(b)&&!rm&&!sm)nameKan=b;
        else if(rm&&/[\u0C80-\u0CFF]{3,}/.test(b))relativeKan=b.replace(rm[0],'').trim();
      }
      if(nameKan)entries.push({serial,partNo,pageNum,nameKan,name:'',relativeKan,relative:'',sex,age,address:'',houseNo:'',relationType:'',epicNo:''});
      i=j; continue;
    }
    i++;
  }
  return entries;
}

// â”€â”€ SEARCH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function doSearch() {
  const name = document.getElementById('s-name').value.trim();
  const rel  = document.getElementById('s-rel').value.trim();
  if (!name && !rel) { alert('Enter at least a name to search.'); return; }
  if (!G.entries.length) { alert('Please process a PDF first.'); return; }

  // Determine if input is Kannada
  const isKannada = str => /[\u0C80-\u0CFF]/.test(str);

  // Since Karnataka rolls are Kannada-only, always prioritise Kannada fields.
  // If the user types English we still search English name (fallback).
  const kanQuery = isKannada(name||rel);
  const fuse = new Fuse(G.entries, {
    includeScore: true,
    threshold: 0.45,
    ignoreLocation: true,
    useExtendedSearch: false,
    keys: [
      { name: 'nameKan',     weight: 0.55 },
      { name: 'name',        weight: 0.15 },
      { name: 'relativeKan', weight: 0.25 },
      { name: 'relative',    weight: 0.05 },
    ]
  });

  const seen = new Set();
  let results = [];

  function add(more) {
    for (const r of more) {
      const k=`${r.item.pageNum}-${r.item.serial}`;
      if (!seen.has(k)) { seen.add(k); results.push(r); }
    }
  }

  // Primary search with both fields
  if (name && rel) {
    add(fuse.search({ $and:[
      { $or: isKannada(name)
          ? [{nameKan:name},{name}]
          : [{name},{nameKan:name}] },
      { $or: isKannada(rel)
          ? [{relativeKan:rel},{relative:rel}]
          : [{relative:rel},{relativeKan:rel}] }
    ]}));
  }

  // Individual field searches to catch partial matches
  if (name) {
    add(isKannada(name)
      ? fuse.search({nameKan:name})
      : fuse.search({name}));
    add(isKannada(name)
      ? fuse.search({name})
      : fuse.search({nameKan:name}));
  }
  if (rel) {
    add(isKannada(rel)
      ? fuse.search({relativeKan:rel})
      : fuse.search({relative:rel}));
  }

  results.sort((a,b)=>(a.score||1)-(b.score||1));
  showResults(results.slice(0,5), name||rel);
}

function showResults(list, query) {
  const wrap=document.getElementById('roll-out');
  const cards=document.getElementById('roll-cards');
  wrap.style.display='block';

  if (!list.length) {
    cards.innerHTML=`<div class="empty"><div class="e-ico">ğŸ”</div><p>No matches found for "<b>${query}</b>".<br>Try a different spelling or check the Kannada script.</p></div>`;
    wrap.scrollIntoView({behavior:'smooth',block:'start'});
    return;
  }

  cards.innerHTML = list.map((r,idx) => {
    const e=r.item;
    const pct=Math.max(0,Math.round((1-(r.score||0))*100));
    const bc=pct>=75?'hi':pct>=50?'mid':'lo';

    // Primary name: Kannada preferred, English fallback
    const nameMain = e.nameKan || e.name || 'â€”';
    // Only show English alt if both exist (Karnataka rolls are Kannada-only)
    const nameAlt  = (e.nameKan && e.name) ? e.name : '';

    // Relative name
    const relMain  = e.relativeKan || e.relative || '';
    const relAlt   = (e.relativeKan && e.relative) ? e.relative : '';
    // Translate relation type for display
    const relTypeMap = {'à²¤à²‚à²¦à³†':'Father','à²—à²‚à²¡':'Husband','à²¤à²¾à²¯à²¿':'Mother','à²ªà²¤à²¿':'Husband','à²‡à²¤à²°à³†':'Other','à²¸à³à²µà²‚à²¤':'Self'};
    const relTypeEng = relTypeMap[e.relationType] || e.relationType || '';
    const relLabel = relTypeEng ? relTypeEng+': ' : '';

    return `
      <div class="result-item${idx===0?' top':''}">
        ${idx===0?'<div class="best-pin">Best Match</div>':''}
        <div class="result-top-row">
          <div style="min-width:0;flex:1">
            <div class="result-name">${nameMain}</div>
            ${nameAlt?`<div class="result-sub">${nameAlt}</div>`:''}
            ${relMain?`<div class="result-sub" style="margin-top:4px">${relLabel}<b>${relMain}</b>${relAlt?' Â· '+relAlt:''}</div>`:''}
          </div>
          <span class="badge ${bc}" style="flex-shrink:0;align-self:flex-start">${pct}%</span>
        </div>
        <div class="result-tags" style="margin-top:10px">
          ${e.serial?`<div class="tag hl">à²•à³à²°à²® à²¸à²‚. <b>${e.serial}</b></div>`:''}
          ${e.houseNo?`<div class="tag">à²®à²¨à³† <b>${e.houseNo}</b></div>`:''}
          ${e.partNo?`<div class="tag hl">à²­à²¾à²— <b>${e.partNo}</b></div>`:''}
          <div class="tag">à²ªà³à²Ÿ <b>${e.pageNum}</b></div>
          ${e.age?`<div class="tag">à²µà²¯à²¸à³à²¸à³ <b>${e.age}</b></div>`:''}
          ${e.sex?`<div class="tag">${e.sex}</div>`:''}
          ${e.epicNo?`<div class="tag">EPIC <b>${e.epicNo}</b></div>`:''}
        </div>
      </div>`;
  }).join('');

  wrap.scrollIntoView({behavior:'smooth',block:'start'});
}

// â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
wireFile('fi-front','front-btn','front-lbl','front-thumb', file => {
  G.frontFile=file;
  document.getElementById('id-btn').disabled=false;
});

wireFile('fi-back','back-btn','back-lbl','back-thumb', file => {
  G.backFile=file;
});

wireFile('fi-pdf','pdf-btn','pdf-lbl',null, file => {
  if (file.type!=='application/pdf') { alert('Please upload a PDF file.'); return; }
  G.pdfFile=file;
  document.getElementById('pdf-btn-go').disabled=false;
});

document.getElementById('s-name').addEventListener('keydown', e=>{ if(e.key==='Enter') doSearch(); });
document.getElementById('s-rel').addEventListener('keydown',  e=>{ if(e.key==='Enter') doSearch(); });
</script>
</body>
</html>
